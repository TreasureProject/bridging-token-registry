Project Path: bridging-token-registry

Source Tree:

```
bridging-token-registry
├── go.mod
├── testnet
│   ├── erc20-data.json
│   ├── erc1155-data.json
│   └── erc721-data.json
├── go.sum
├── schemas
│   └── tokenSchema.json
├── README.md
├── mainnet
│   ├── erc20-data.json
│   ├── erc1155-data.json
│   └── erc721-data.json
└── main.go

```

`/Users/mulf/Work/bridging-token-registry/go.mod`:

```mod
module github.com/TreasureProject/bridging-token-registry

go 1.22.1

require (
	github.com/santhosh-tekuri/jsonschema/v6 v6.0.1 // indirect
	golang.org/x/text v0.14.0 // indirect
)

```

`/Users/mulf/Work/bridging-token-registry/testnet/erc20-data.json`:

```json
{
  "tokens": [
    {
      "name": "Magic Gold",
      "srcChainId": 5,
      "destChainId": 80001,
      "srcTokenAddress": "0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1",
      "destTokenAddress": "0x3D9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
      "isNft": false,
      "isCollateral": true,
      "underlyingTokenAddress": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    },
    {
      "name": "Mystic Gems",
      "srcChainId": 80001,
      "destChainId": 421613,
      "srcTokenAddress": "0xE11BA2b4D45Eaed5996cd0824791E0C93114882d",
      "destTokenAddress": "0x1dD8E8BD0e5c7759B006C2f7985233B3887E57e1",
      "isNft": false,
      "isCollateral": false
    }
  ]
}

```

`/Users/mulf/Work/bridging-token-registry/testnet/erc1155-data.json`:

```json
{
  "tokens": [
    {
      "name": "Magic Items",
      "srcChainId": 5,
      "destChainId": 420,
      "srcTokenAddress": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
      "destTokenAddress": "0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1",
      "isNft": true,
      "nftStandard": "ERC1155",
      "isCollateral": true,
      "underlyingTokenAddress": "0x3D9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
      "nftBatchSignature": "send((uint32,bytes32,uint256,uint256,bytes,bytes,bytes),(uint256,uint256),address)"
    },
    {
      "name": "Battle Equipment",
      "srcChainId": 80001,
      "destChainId": 421613,
      "srcTokenAddress": "0x1dD8E8BD0e5c7759B006C2f7985233B3887E57e1",
      "destTokenAddress": "0x5a32119C68032d4F2F8cDB072E89f12550f2B782",
      "isNft": true,
      "nftStandard": "ERC1155",
      "isCollateral": false,
      "nftBatchSignature": "send((uint32,bytes32,uint256,uint256,bytes,bytes,bytes),(uint256,uint256),address)"
    }
  ]
}

```

`/Users/mulf/Work/bridging-token-registry/testnet/erc721-data.json`:

```json
{
  "tokens": [
    {
      "name": "Legendary Heroes",
      "srcChainId": 421613,
      "destChainId": 5,
      "srcTokenAddress": "0x5a32119C68032d4F2F8cDB072E89f12550f2B782",
      "destTokenAddress": "0x8fC72388B128B36890057b1b4f4C9746d7157f2E",
      "isNft": true,
      "nftStandard": "ERC721",
      "isCollateral": false,
      "nftBatchSignature": "send((uint32,bytes32,uint256,uint256,bytes,bytes,bytes),(uint256,uint256),address)"
    },
    {
      "name": "Ancient Relics",
      "srcChainId": 5,
      "destChainId": 80001,
      "srcTokenAddress": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
      "destTokenAddress": "0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1",
      "isNft": true,
      "nftStandard": "ERC721",
      "isCollateral": true,
      "underlyingTokenAddress": "0x3D9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
      "nftBatchSignature": "send((uint32,bytes32,uint256,uint256,bytes,bytes,bytes),(uint256,uint256),address)"
    }
  ]
}

```

`/Users/mulf/Work/bridging-token-registry/go.sum`:

```sum
github.com/santhosh-tekuri/jsonschema/v6 v6.0.1 h1:PKK9DyHxif4LZo+uQSgXNqs0jj5+xZwwfKHgph2lxBw=
github.com/santhosh-tekuri/jsonschema/v6 v6.0.1/go.mod h1:JXeL+ps8p7/KNMjDQk3TCwPpBy0wYklyWTfbkIzdIFU=
golang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=
golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=

```

`/Users/mulf/Work/bridging-token-registry/schemas/tokenSchema.json`:

```json
{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "title": "Treasure Bridging Registry",
  "type": "object",
  "properties": {
    "tokens": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "name": { "type": "string" },
          "srcChainId": { "type": "integer" },
          "destChainId": { "type": "integer" },
          "srcTokenAddress": {
            "type": "string",
            "pattern": "^0x[a-fA-F0-9]{40}$"
          },
          "destTokenAddress": {
            "type": "string",
            "pattern": "^0x[a-fA-F0-9]{40}$"
          },
          "isNft": { "type": "boolean" },
          "isCollateral": { "type": "boolean" },
          "nftStandard": {
            "type": "string",
            "enum": ["ERC721", "ERC1155"]
          },
          "underlyingTokenAddress": {
            "type": "string",
            "pattern": "^0x[a-fA-F0-9]{40}$"
          },
          "nftBatchSignature": { "type": "string" }
        },
        "required": [
          "name",
          "srcChainId",
          "destChainId",
          "srcTokenAddress",
          "destTokenAddress",
          "isNft",
          "isCollateral"
        ],
        "allOf": [
          {
            "if": {
              "properties": { "isNft": { "const": true } }
            },
            "then": {
              "required": ["nftStandard", "nftBatchSignature"]
            }
          },
          {
            "if": {
              "properties": { "isCollateral": { "const": true } }
            },
            "then": {
              "required": ["underlyingTokenAddress"]
            }
          }
        ]
      }
    }
  }
}

```

`/Users/mulf/Work/bridging-token-registry/README.md`:

```md
# Treasure Bridged Token Registry

```

`/Users/mulf/Work/bridging-token-registry/mainnet/erc20-data.json`:

```json
{
  "tokens": [
    {
      "name": "Super Gold",
      "srcChainId": 5,
      "destChainId": 80001,
      "srcTokenAddress": "0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1",
      "destTokenAddress": "0x3D9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
      "isNft": false,
      "isCollateral": true,
      "underlyingTokenAddress": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
    },
    {
      "name": "Mystic Gems",
      "srcChainId": 80001,
      "destChainId": 421613,
      "srcTokenAddress": "0xE11BA2b4D45Eaed5996cd0824791E0C93114882d",
      "destTokenAddress": "0x1dD8E8BD0e5c7759B006C2f7985233B3887E57e1",
      "isNft": false,
      "isCollateral": false
    }
  ]
}

```

`/Users/mulf/Work/bridging-token-registry/mainnet/erc1155-data.json`:

```json
{
  "tokens": [
    {
      "name": "Magic Items",
      "srcChainId": 5,
      "destChainId": 420,
      "srcTokenAddress": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
      "destTokenAddress": "0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1",
      "isNft": true,
      "nftStandard": "ERC1155",
      "isCollateral": true,
      "underlyingTokenAddress": "0x3D9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
      "nftBatchSignature": "send((uint32,bytes32,uint256,uint256,bytes,bytes,bytes),(uint256,uint256),address)"
    },
    {
      "name": "Battle Equipment",
      "srcChainId": 80001,
      "destChainId": 421613,
      "srcTokenAddress": "0x1dD8E8BD0e5c7759B006C2f7985233B3887E57e1",
      "destTokenAddress": "0x5a32119C68032d4F2F8cDB072E89f12550f2B782",
      "isNft": true,
      "nftStandard": "ERC1155",
      "isCollateral": false,
      "nftBatchSignature": "send((uint32,bytes32,uint256,uint256,bytes,bytes,bytes),(uint256,uint256),address)"
    }
  ]
}

```

`/Users/mulf/Work/bridging-token-registry/mainnet/erc721-data.json`:

```json
{
  "tokens": [
    {
      "name": "Legendary Heroes",
      "srcChainId": 421613,
      "destChainId": 5,
      "srcTokenAddress": "0x5a32119C68032d4F2F8cDB072E89f12550f2B782",
      "destTokenAddress": "0x8fC72388B128B36890057b1b4f4C9746d7157f2E",
      "isNft": true,
      "nftStandard": "ERC721",
      "isCollateral": false,
      "nftBatchSignature": "send((uint32,bytes32,uint256,uint256,bytes,bytes,bytes),(uint256,uint256),address)"
    },
    {
      "name": "Ancient Relics",
      "srcChainId": 5,
      "destChainId": 80001,
      "srcTokenAddress": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
      "destTokenAddress": "0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1",
      "isNft": true,
      "nftStandard": "ERC721",
      "isCollateral": true,
      "underlyingTokenAddress": "0x3D9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
      "nftBatchSignature": "send((uint32,bytes32,uint256,uint256,bytes,bytes,bytes),(uint256,uint256),address)"
    }
  ]
}

```

`/Users/mulf/Work/bridging-token-registry/main.go`:

```go
package main

import (
	"fmt"
	"os"

	"github.com/santhosh-tekuri/jsonschema/v6"
)

type validationError struct {
	tokenType TokenType
	err       error
	file      string
}

type TokenType string

const (
	ERC20   TokenType = "erc20"
	ERC721  TokenType = "erc721"
	ERC1155 TokenType = "erc1155"
)

func main() {
	var errors []validationError
	comp := jsonschema.NewCompiler()

	// Single schema for all token types
	schemaLocation := "schemas/tokenSchema.json"

	// Data file locations by token type
	dataFiles := map[TokenType][2]string{
		ERC20: {
			"testnet/erc20-data.json",
			"mainnet/erc20-data.json",
		},
		ERC721: {
			"testnet/erc721-data.json",
			"mainnet/erc721-data.json",
		},
		ERC1155: {
			"testnet/erc1155-data.json",
			"mainnet/erc1155-data.json",
		},
	}

	// Compile the single schema
	if _, err := os.Stat(schemaLocation); os.IsNotExist(err) {
		fmt.Printf("Schema file not found: %s\n", err)
		os.Exit(1)
	}

	schema, err := comp.Compile(schemaLocation)
	if err != nil {
		fmt.Printf("Schema compilation error: %s\n", err)
		os.Exit(1)
	}

	// Validate each data file against the schema
	for tokenType, locations := range dataFiles {
		for _, fileLocation := range locations {
			if _, err := os.Stat(fileLocation); os.IsNotExist(err) {
				errors = append(errors, validationError{
					tokenType: tokenType,
					err:       err,
					file:      fileLocation,
				})
				continue
			}

			file, err := os.Open(fileLocation)
			if err != nil {
				errors = append(errors, validationError{
					tokenType: tokenType,
					err:       err,
					file:      fileLocation,
				})
				continue
			}

			inst, err := jsonschema.UnmarshalJSON(file)
			if err != nil {
				errors = append(errors, validationError{
					tokenType: tokenType,
					err:       err,
					file:      fileLocation,
				})
				file.Close()
				continue
			}

			file.Close()

			err = schema.Validate(inst)
			if err != nil {
				errors = append(errors, validationError{
					tokenType: tokenType,
					err:       err,
					file:      fileLocation,
				})
			}
		}
	}

	if len(errors) > 0 {
		fmt.Println("Validation errors occurred:")
		for _, err := range errors {
			fmt.Printf("%s: %s in file %s\n", err.tokenType, err.err.Error(), err.file)
		}
		os.Exit(1)
	}

	fmt.Println("All token configurations validated successfully")
}

```